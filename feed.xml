<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Learning Python with the Leetcode Problemset</title>
    <description>This blog documents my road to learn Python by solving programming problems on leetcode.com. I will be adding a post for each problem worthy of discussion.
</description>
    <link>http://yebrahim.github.io/leetcode-python-solutions/</link>
    <atom:link href="http://yebrahim.github.io/leetcode-python-solutions/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 27 Apr 2016 19:35:24 -0700</pubDate>
    <lastBuildDate>Wed, 27 Apr 2016 19:35:24 -0700</lastBuildDate>
    <generator>Jekyll v3.1.3</generator>
    
      <item>
        <title>p122 - Best Time to Buy and Sell Stock II </title>
        <description>&lt;h1 id=&quot;problem&quot;&gt;Problem&lt;/h1&gt;
&lt;p&gt;Given an array that represents prices for a certain stock on each day, find the maximum profit that can be obtained by buying and selling the stock multiple times on different days.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/&quot;&gt;Read original problem statement on leetcode&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;discussion&quot;&gt;Discussion&lt;/h1&gt;
&lt;p&gt;This is one of the problems that python can handle best in one line. First, the naive iterative approach works best here, you just need to find all positive deltas between consecutive stock prices and sum them up. The reason this works is because you can sell a stock then buy it on the same day (probably a &lt;a href=&quot;https://en.wikipedia.org/wiki/Wash_sale&quot;&gt;bad idea in real life&lt;/a&gt;). If we couldn’t do this, we would have ended up having to optimize which deltas to take and which to ignore.&lt;/p&gt;

&lt;h1 id=&quot;solution&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;There are several ways to solve this problem. One is to use a for-loop to look at the deltas between each element and the previous one, and sum the positive deltas. Easy to implement, but boring. One other way is to use python’s functional programming parts, maybe using a &lt;a href=&quot;https://docs.python.org/3.3/library/functions.html#map&quot;&gt;map function&lt;/a&gt; that returns the delta if it’s positive, and zero otherwise, then doing a sum over the resulting array.&lt;/p&gt;

&lt;p&gt;What I ended up doing here is using a &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.reduce&quot;&gt;reduce function&lt;/a&gt; with a &lt;a href=&quot;https://docs.python.org/2/reference/expressions.html#lambda&quot;&gt;lambda function&lt;/a&gt; that takes the resulting sum so far and the next element, and returns the sum plus the delta if positive or just the sum otherwise. One corner case to handle when using a reduce is to check that the array isn’t empty. The reduce implementation in the functools will throw when given an empty array, since it considers the first element its seed for the running reduction, so it wouldn’t know what to return in this case. Another option is to use an initializer.&lt;/p&gt;

&lt;h1 id=&quot;code&quot;&gt;Code&lt;/h1&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;functools&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;maxProfit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;functools&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Tue, 26 Apr 2016 19:24:13 -0700</pubDate>
        <link>http://yebrahim.github.io/leetcode-python-solutions/medium/2016/04/26/p122-best-time-to-buy-stock-ii.html</link>
        <guid isPermaLink="true">http://yebrahim.github.io/leetcode-python-solutions/medium/2016/04/26/p122-best-time-to-buy-stock-ii.html</guid>
        
        
        <category>medium</category>
        
      </item>
    
      <item>
        <title>p20 - Valid Parentheses</title>
        <description>&lt;h1 id=&quot;problem&quot;&gt;Problem&lt;/h1&gt;
&lt;p&gt;Given a string of only three types of parantheses (and their closing counterparts) &lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;[&#39;, &#39;(&#39;, &#39;{&#39;, &#39;]&#39;, &#39;)&#39;, &#39;}&#39;&lt;/code&gt; we’re required to return true if and only if they are properly closed. For example &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;([])&quot;&lt;/code&gt; is valid, whereas &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;({(}))&quot;&lt;/code&gt; is not.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-parentheses/&quot;&gt;Read original problem statement on leetcode&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;discussion&quot;&gt;Discussion&lt;/h1&gt;
&lt;p&gt;A stack should immediately come to mind when solving this problem. The reason is we can open parentheses in any order, but the real check comes when we see closing parentheses. Whenever we see a closed parenthesis, it should have immediately followed an open parenthesis of the same type, all the characters that are allowed in the input are parentheses. A stack helps keep track of the most recently encountered items, so all we need to do is all open parantheses on the stack until we meet a closed parenthesis, in which case it should match the item on the top of the stack, we pop it if that’s the case and continue matching. You can easily see this is a linear &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt; solution in both time and space.&lt;/p&gt;

&lt;p&gt;When solving the problem this way, you can look at it from a different angle. We ‘ignore’ open parentheses, but closed parentheses will nullify the last open ones. In other words, all such pairs &lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;()&#39;&lt;/code&gt; and the likes can be safely ommitted from the input string, which will likely form other pairs. Removing these simplifies the string as well. If we continue doing this, we should either finally hit an empty string, in which case the string was valid, or a non-empty string that cannot be simplified any further, in which case it was not.&lt;/p&gt;

&lt;p&gt;This solution is evidently more time-consuming &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n^2)&lt;/code&gt;, although it can be written surprisingly briefly in Python. But because we’re concerned with performance too, we’ll ignore this solution.&lt;/p&gt;

&lt;h1 id=&quot;solution&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;I’m doing something extra here, which is trimming the string down to parentheses only, in case we had any other characters. We do this using the python regex module &lt;code class=&quot;highlighter-rouge&quot;&gt;(re)&lt;/code&gt; which can replace a substring based on a regex. Next, we create a dictionary that maps closing parentheses to their open counterparts. We do the mapping this way because closing parentheses are kind of the ‘trigger’ for our matching algorithm. After that, we loop over all characters, and since using &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt; on the the dicionary checks against its keys, we can push all non-key characters (which are open parentheses) to the stack, and pop otherwise after testing the match.&lt;/p&gt;

&lt;h1 id=&quot;code&quot;&gt;Code&lt;/h1&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isValid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&#39;[^&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;}}]&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;braces&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;}&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;{&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;)&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;(&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;]&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&#39;[&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;myStack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;braces&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;braces&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;myStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Sat, 02 Apr 2016 19:24:13 -0700</pubDate>
        <link>http://yebrahim.github.io/leetcode-python-solutions/easy/2016/04/02/p20-valid-parentheses.html</link>
        <guid isPermaLink="true">http://yebrahim.github.io/leetcode-python-solutions/easy/2016/04/02/p20-valid-parentheses.html</guid>
        
        
        <category>easy</category>
        
      </item>
    
  </channel>
</rss>
